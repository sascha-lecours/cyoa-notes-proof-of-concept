{"ast":null,"code":"/**\n * The libinkle module component\n * \n * Exports an object builder able to import, read and run through an inkle writer story\n * \n * \n * \n * \n * @type module\n */\nconst _ = require('lodash');\n/**\n * Story Model\n * Encapsulates an inkle history metadata and stitches list\n * @param {string} string   Stringified JSON object\n * @class \n */\n\n\nvar storyModel = function (string, inkle) {\n  this.inkle = inkle;\n  this.story = JSON.parse(string);\n  this.stitches = this.story.data.stitches;\n  /**\n   * A simple object to access the critical story informations\n   */\n\n  this.stats = {\n    updatedAt: this.story.updated_at,\n    title: this.story.title,\n    initial: this.story.data.initial,\n    stitchesCount: _.size(this.stitches)\n  };\n  var stitches = this.story.data.stitches;\n\n  var stitchesKeys = _.keys(this.story.data.stitches).sort();\n\n  return this;\n};\n/*\n * Retrieve a single \"stitch\" by string\n * @method getStitch\n * @param {string} stitch_name\n * @returns {nm$_libinkle.stitchModel}\n */\n\n\nstoryModel.prototype.getStitch = function (stitch_name) {\n  if (_.has(this.story.data.stitches, stitch_name)) {\n    return new stitchModel(this.story.data.stitches[stitch_name], stitch_name, this.inkle);\n  }\n\n  msg = 'No stitch found for ' + stitch_name;\n  throw msg;\n};\n/**\n * Encapsulates a single stitch\n * @class\n * @param {object} stitch A serialized stitch to be hydrated\n * @param {string} name the ID of the stitch\n */\n\n\nvar stitchModel = function (stitch, name, inkle) {\n  var flagList = inkle.flagList;\n  var content = stitch.content;\n  this.name = name || 'unknown';\n  this.choices = {};\n  content.forEach((value, key) => {\n    // is it a message\n    if (_.isString(value)) {\n      this.message = value;\n    } // is it a divert\n    else if (_.has(value, 'divert')) {\n        this.divert = value.divert;\n      } // is it an image \n      else if (_.has(value, 'image')) {\n          this.image = value.image;\n        } // is it a flag\n        else if (_.has(value, 'flagName')) {\n            flagList.push(value['flagName']);\n          } // it it a choice\n          else if (_.has(value, 'linkPath')) {\n              // it should check conditions \n              var absentFlagErrors = [];\n              var presentFlagErrors = [];\n              debugger; // has negate conditions \n\n              if (value['notIfConditions'] && value['notIfConditions'].length > 0) {\n                value['notIfConditions'].forEach(function (flagContainer) {\n                  if (flagList.indexOf(flagContainer['notIfCondition']) !== -1) {\n                    absentFlagErrors.push(flagContainer['notIfCondition']);\n                  }\n                });\n              } // has positive conditions \n\n\n              if (value['ifConditions'] && value['ifConditions'].length > 0) {\n                value['ifConditions'].forEach(function (flagContainer) {\n                  if (flagList.indexOf(flagContainer['ifCondition']) === -1) {\n                    presentFlagErrors.push(flagContainer['ifCondition']);\n                  }\n                });\n              }\n\n              if (absentFlagErrors.length === 0 && presentFlagErrors.length === 0) {\n                this.choices[value['linkPath']] = value['option'];\n              }\n            }\n  });\n\n  this.isFinal = function () {\n    return content.length === 1;\n  };\n\n  this.isChoice = function () {\n    return _.keys(this.choices).length > 0;\n  };\n\n  this.nextStitch = function () {\n    return this.divert;\n  };\n\n  this.getText = function () {\n    return this.message;\n  };\n\n  this.getChoices = function () {\n    return this.choices;\n  };\n\n  return this;\n};\n/**\n * \n * @param {object} options\n * @returns {nm$_libinkle.inkle}\n * @class\n */\n\n\ninkle = function (options) {\n  _.assign(this, options);\n\n  this.flagList = [];\n  this.paragraphList = null;\n  this.choicesList = null;\n  var story = this.story || null;\n\n  if (_.has(this, 'source')) {\n    this.story = new storyModel(this.source, this);\n  }\n};\n/**\n * Static story models factory\n * \n * @param {string} string a JSON file\n * @returns {nm$_libinkle.storyModel|Object.prototype.parse.story}\n */\n\n\ninkle.prototype.parse = function (string) {\n  const story = new storyModel(string, this);\n  return story;\n};\n/**\n * Static story model stats builder\n * \n * @param {string} story\n * @returns {inkle.prototype.stats.story.stats|.inkle.prototype@call;parse.stats|Object.prototype.stats.stats}\n */\n\n\ninkle.prototype.stats = function (story) {\n  var story = typeof story === 'string' ? inkle.prototype.parse(story) : story;\n  var stats = story.stats;\n  return stats;\n};\n/**\n * Retrieves from a single stich all connected stitches \n * \n * @param {string} stitch_name  A stitch key  \n * @returns {Boolean}\n */\n\n\ninkle.prototype.start = function (stitch_name) {\n  stitch_name = stitch_name || this.story.stats.initial;\n  const initial = this.story.getStitch(stitch_name);\n  this.currentStitches = this.getAllStitches(initial);\n  return this;\n};\n/**\n * From a single Stitch Model, retrieves all related stitches until choice occurs\n * \n * @param {type} currentStitch\n * @returns {Boolean}\n */\n\n\ninkle.prototype.getAllStitches = function (currentStitch) {\n  var final = false;\n  var choice = false;\n  this.paragraphList = [];\n  this.choicesList = [];\n  var nextStitch = '';\n\n  while (final === false && choice === false) {\n    this.paragraphList.push(currentStitch.getText());\n\n    if (currentStitch.isChoice()) {\n      choice = true;\n      this.choicesList = currentStitch.getChoices();\n    } else if (currentStitch.isFinal()) {\n      final = true;\n    } else {\n      nextStitch = currentStitch.nextStitch();\n      currentStitch = this.story.getStitch(nextStitch);\n    }\n  }\n\n  return true;\n};\n/**\n * Return text paragraphs at current stage\n * \n * @returns {Array} \n */\n\n\ninkle.prototype.getText = function () {\n  return this.paragraphList;\n};\n/**\n * Return choices paragraphs at current stage in the form\n *  stitch_link => question paragraph\n * \n * @returns {Array}\n */\n\n\ninkle.prototype.getChoices = function () {\n  return this.choicesList;\n};\n/**\n * Returns a list of current choices only by stitch name\n * \n * @returns {Boolean}\n */\n\n\ninkle.prototype.getChoicesByName = function () {\n  return _.keys(this.choicesList);\n};\n/**\n * Decide to progress based on a given choice, by stitch_name\n * \n * @param {type} stitch_name\n * @returns {Boolean}\n */\n\n\ninkle.prototype.choose = function (stitch_name) {\n  return this.start(stitch_name);\n};\n/**\n * Let chance decide the next story move\n * \n * @returns {Array|nm$_libinkle.inkle.prototype.chooseRandom.choices}\n */\n\n\ninkle.prototype.chooseRandom = function () {\n  var choices = this.getChoices();\n  var choicesList = this.getChoicesByName();\n  var choice = Math.floor(Math.random() * choicesList.length);\n  this.choose(choicesList[choice]);\n  return choices[choicesList[choice]];\n};\n/**\n * Simple helper : is story not fnished?\n * \n * @returns {Boolean}\n */\n\n\ninkle.prototype.isNotFinished = function () {\n  return this.getChoicesByName().length !== 0;\n};\n/**\n * Simple helper : is story fnished?\n * \n * @returns {Boolean}\n */\n\n\ninkle.prototype.isFinished = function () {\n  return this.getChoicesByName().length === 0;\n};\n\nmodule.exports = inkle;","map":{"version":3,"sources":["C:/Users/sasch/git_repos/react-nodejs-example/my-app/node_modules/libinkle/index.js"],"names":["_","require","storyModel","string","inkle","story","JSON","parse","stitches","data","stats","updatedAt","updated_at","title","initial","stitchesCount","size","stitchesKeys","keys","sort","prototype","getStitch","stitch_name","has","stitchModel","msg","stitch","name","flagList","content","choices","forEach","value","key","isString","message","divert","image","push","absentFlagErrors","presentFlagErrors","length","flagContainer","indexOf","isFinal","isChoice","nextStitch","getText","getChoices","options","assign","paragraphList","choicesList","source","start","currentStitches","getAllStitches","currentStitch","final","choice","getChoicesByName","choose","chooseRandom","Math","floor","random","isNotFinished","isFinished","module","exports"],"mappings":"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","sourcesContent":["/**\n * The libinkle module component\n * \n * Exports an object builder able to import, read and run through an inkle writer story\n * \n * \n * \n * \n * @type module\n */\nconst _ = require('lodash');\n\n/**\n * Story Model\n * Encapsulates an inkle history metadata and stitches list\n * @param {string} string   Stringified JSON object\n * @class \n */\nvar storyModel = function (string, inkle) {\n    this.inkle = inkle;\n    this.story = JSON.parse(string);\n    this.stitches = this.story.data.stitches;\n    /**\n     * A simple object to access the critical story informations\n     */\n    this.stats = {\n        updatedAt: this.story.updated_at,\n        title: this.story.title,\n        initial: this.story.data.initial,\n        stitchesCount: _.size(this.stitches),\n    };\n    var stitches = this.story.data.stitches;\n    var stitchesKeys = _.keys(this.story.data.stitches).sort();\n    return this;\n};\n/*\n * Retrieve a single \"stitch\" by string\n * @method getStitch\n * @param {string} stitch_name\n * @returns {nm$_libinkle.stitchModel}\n */\nstoryModel.prototype.getStitch = function (stitch_name) {\n    if (_.has(this.story.data.stitches, stitch_name)) {\n        return new stitchModel(this.story.data.stitches[stitch_name], stitch_name, this.inkle);\n    }\n    msg = 'No stitch found for ' + stitch_name;\n    throw msg;\n};\n\n/**\n * Encapsulates a single stitch\n * @class\n * @param {object} stitch A serialized stitch to be hydrated\n * @param {string} name the ID of the stitch\n */\nvar stitchModel = function (stitch, name, inkle) {\n    var flagList = inkle.flagList;\n    var content = stitch.content;\n    this.name = name || 'unknown';\n    this.choices = {};\n    content.forEach((value, key) => {\n        // is it a message\n        if (_.isString(value)) {\n            this.message = value;\n        }\n        // is it a divert\n        else if (_.has(value, 'divert')) {\n            this.divert = value.divert;\n        }\n        // is it an image \n        else if (_.has(value, 'image')) {\n            this.image = value.image;\n        }\n        // is it a flag\n        else if (_.has(value, 'flagName')) {\n            flagList.push(value['flagName']);\n        }\n        // it it a choice\n        else if (_.has(value, 'linkPath')) {\n            // it should check conditions \n            var absentFlagErrors = [];\n            var presentFlagErrors = [];\n            debugger\n            // has negate conditions \n            if (value['notIfConditions'] && value['notIfConditions'].length > 0) {\n                value['notIfConditions'].forEach(function (flagContainer) {\n                    if (flagList.indexOf(flagContainer['notIfCondition']) !== -1) {\n                        absentFlagErrors.push(flagContainer['notIfCondition']);\n                    }\n                });\n            }\n            // has positive conditions \n            if (value['ifConditions'] && value['ifConditions'].length > 0) {\n                value['ifConditions'].forEach(function (flagContainer) {\n                    if (flagList.indexOf(flagContainer['ifCondition']) === -1) {\n                        presentFlagErrors.push(flagContainer['ifCondition']);\n                    }\n                });\n            }\n            if (absentFlagErrors.length === 0  && presentFlagErrors.length === 0 ) {\n                this.choices[value['linkPath']] = value['option'];\n            }\n        }\n    });\n    this.isFinal = function () {\n        return content.length === 1;\n    };\n    this.isChoice = function () {\n        return _.keys(this.choices).length > 0;\n    };\n    this.nextStitch = function () {\n        return this.divert;\n    };\n    this.getText = function () {\n        return this.message;\n    };\n    this.getChoices = function () {\n        return this.choices;\n    };\n\n    return this;\n};\n\n/**\n * \n * @param {object} options\n * @returns {nm$_libinkle.inkle}\n * @class\n */\ninkle = function (options) {\n    _.assign(this, options);\n    this.flagList = [];\n    this.paragraphList = null;\n    this.choicesList = null;\n    var story = this.story || null;\n    if (_.has(this, 'source')) {\n        this.story = new storyModel(this.source, this);\n    }\n};\n\n/**\n * Static story models factory\n * \n * @param {string} string a JSON file\n * @returns {nm$_libinkle.storyModel|Object.prototype.parse.story}\n */\ninkle.prototype.parse = function (string) {\n    const story = new storyModel(string, this);\n    return story;\n};\n\n/**\n * Static story model stats builder\n * \n * @param {string} story\n * @returns {inkle.prototype.stats.story.stats|.inkle.prototype@call;parse.stats|Object.prototype.stats.stats}\n */\ninkle.prototype.stats = function (story) {\n    var story = (typeof story === 'string') ? inkle.prototype.parse(story) : story;\n    var stats = story.stats;\n    return stats;\n};\n\n/**\n * Retrieves from a single stich all connected stitches \n * \n * @param {string} stitch_name  A stitch key  \n * @returns {Boolean}\n */\ninkle.prototype.start = function (stitch_name) {\n    stitch_name = stitch_name || this.story.stats.initial;\n    const initial = this.story.getStitch(stitch_name);\n    this.currentStitches = this.getAllStitches(initial);\n    return this;\n};\n\n/**\n * From a single Stitch Model, retrieves all related stitches until choice occurs\n * \n * @param {type} currentStitch\n * @returns {Boolean}\n */\ninkle.prototype.getAllStitches = function (currentStitch) {\n    var final = false;\n    var choice = false;\n    this.paragraphList = [];\n    this.choicesList = [];\n    var nextStitch = '';\n    while (final === false && choice === false) {\n        this.paragraphList.push(currentStitch.getText());\n        if (currentStitch.isChoice()) {\n            choice = true;\n            this.choicesList = currentStitch.getChoices();\n        } else if (currentStitch.isFinal()) {\n            final = true;\n        } else {\n            nextStitch = currentStitch.nextStitch();\n            currentStitch = this.story.getStitch(nextStitch)\n        }\n    }\n    return true;\n};\n\n/**\n * Return text paragraphs at current stage\n * \n * @returns {Array} \n */\ninkle.prototype.getText = function () {\n    return this.paragraphList;\n};\n\n/**\n * Return choices paragraphs at current stage in the form\n *  stitch_link => question paragraph\n * \n * @returns {Array}\n */\ninkle.prototype.getChoices = function () {\n    return this.choicesList;\n};\n\n/**\n * Returns a list of current choices only by stitch name\n * \n * @returns {Boolean}\n */\ninkle.prototype.getChoicesByName = function () {\n    return _.keys(this.choicesList);\n};\n\n/**\n * Decide to progress based on a given choice, by stitch_name\n * \n * @param {type} stitch_name\n * @returns {Boolean}\n */\ninkle.prototype.choose = function (stitch_name) {\n    return this.start(stitch_name);\n};\n\n/**\n * Let chance decide the next story move\n * \n * @returns {Array|nm$_libinkle.inkle.prototype.chooseRandom.choices}\n */\ninkle.prototype.chooseRandom = function () {\n    var choices = this.getChoices();\n    var choicesList = this.getChoicesByName();\n    var choice = Math.floor(Math.random() * choicesList.length);\n    this.choose(choicesList[choice]);\n    return choices[choicesList[choice]];\n};\n\n/**\n * Simple helper : is story not fnished?\n * \n * @returns {Boolean}\n */\ninkle.prototype.isNotFinished = function () {\n    return this.getChoicesByName().length !== 0;\n};\n\n/**\n * Simple helper : is story fnished?\n * \n * @returns {Boolean}\n */\ninkle.prototype.isFinished = function () {\n    return this.getChoicesByName().length === 0;\n};\n\n\nmodule.exports = inkle;\n"]},"metadata":{},"sourceType":"script"}